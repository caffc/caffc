module caffc

_caffc_str_size(i32 size) -> i32 {
  i32 result

  native {
    result = (i32) (sizeof(u8) * size + sizeof(caffc_str));
  }

  return result
}

/**
 * A basic string.
 */
#caffc_array("u8")
class str {
  i32 size   // size in bytes, including nul byte
  bool ascii // is the code ASCII, or is it really UTF-8

  constructor(i32 size) {
    _this.size = size
  }

  c_str() -> ptr {
    ptr result

    native {
      result = _this->_caffc_data;
    }

    return result
  }

  /**
   * Creates a copy of the bytes until the first nul byte and creates a new `str` instance.
   * The `ptr` isn't stored internally.
   */
  static fromPtr(ptr data) -> str {
     u32 stringLen = _strlen(data)
     str result = new str(stringLen + 1)

     native {
       char* dst = result->_caffc_data;
       char* src = data;

       while (*src) {
         *dst = *src;
         dst++;
         src++;
       }

       *dst = 0;
     }

     return result
  }

  /**
   * Concatenates the current `str`, with the other `str`, into a new `str`
   * instance.
   */
  add(str other) -> str {
    return null
  }

  /**
   * Slices the current `str` into a new `str`. `start` and `end` positions are
   * character indexes.
   */
  slice(i32 start, i32 end) -> str {
  }

  starts_with(str other) -> bool {
  }

  ends_with(str other) -> bool {
  }

  /**
   * Returns the character at the given character position.
   */
  char_at(i32 index) -> u32 {
  }

  /**
   * Returns the byte at the given byte position.
   */
  byte_at(i32 index) -> u8 {
    if (u32) index >= (u32) _this.size {
      throw new Exception("dead")
    }

    u8 result

    native {
      result = _this->_caffc_data[index]
    }

    return result
  }
}

/**
 * Computes the length of the given string. The same as the normal
 * C `strlen`, but without the libc dependency.
 */
_strlen(ptr data) -> i32 {
  i32 result = 0

  native {
    while (*((char*)data)) {
      result += 1;
      data = (ptr) (((char*)data) + 1);
    }
  }

  return result
}

