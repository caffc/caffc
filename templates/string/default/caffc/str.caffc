module caffc

_caffc_str_size(i32 size) -> i32 {
  i32 result

  native {
    result = (i32) (sizeof(u8) * size + sizeof(caffc_str));
  }

  return result
}

/**
 * A basic string. This implementation only holds ASCII strings.
 */
#public #caffc_array("u8")
class str {
  i32 _byte_length   // size in bytes, including nul byte. this only holds ASCII strings

  constructor(i32 size) {
    if size <= 0 {
      raise("invalid string size.")
    }

    _this._byte_length = size
  }

  /**
   * Creates a copy of the bytes until the first nul byte and creates a new `str` instance.
   * The `ptr` reference isn't stored internally, and a copy of the string will be made.
   */
  #public
  static fromPtr(ptr data) -> str {
     u32 stringLen
     str result

     native {
       stringLen = caffc_strlen(data);
     }

     result = new str(stringLen + 1)

     native {
       caffc_memcpy(result->_caffc_data, data, result);
     }

     return result
  }

  /**
   * Concatenates the current `str`, with the other `str`, into a new `str`
   * instance.
   */
  #public
  add(str other) -> str {
    if not other {
      raise("illegal null argument")
    }

    str result = new str(_this._byte_length + other._byte_length - 1)

    native {
      caffc_memcpy(result->_caffc_data, _this->_caffc_data, _this->_byte_length - 1);
      caffc_memcpy(result->_caffc_data + _this->_byte_length - 1,
                   other->_caffc_data, other->_byte_length); // this copies also the nul byte
    }

    return result
  }

  /**
   * Slices the current `str` into a new `str`. `start` and `end` positions are
   * character indexes (they can be negative). `0` for the `end_index` means
   * `_this.size()`
   */
  #public
  slice(i32 start_index, i32 end_index) -> str {
      if start_index < 0 {
        start_index = (i32) _this._byte_length + start_index - 1
      }

      if (u32) start_index >= (u32) _this._byte_length {
        raise("start_index out of bounds")
      }

      if end_index <= 0 {
        end_index = (i32) _this._byte_length + end_index - 1
      }

      if (u32) end_index > (u32) _this._byte_length {
        raise("end_index out of bounds")
      }

      if start_index > end_index {
        raise("start_index > end_index")
      }

      str result = new str(end_index - start_index + 1)

      native {
        caffc_memcpy(result->_caffc_data,
                     _this->_caffc_data + start_index, result->_byte_length - 1);
        result->_caffc_data[result->_byte_length - 1] = 0;
      }

      return result
  }

  /**
   * Returns the character at the given character position.
   */
  #public
  get(i32 index) -> u32 {
    if index < 0 {
      index = (i32) _this._byte_length + index
    }

    if (u32) index >= (u32) _this._byte_length {
      raise("index out of bounds")
    }

    u32 result

    native {
      result = (u32) _this->_caffc_data[index];
    }

    return result
  }

  /**
   * Returns the size of this string in _characters_. It excludes the nul byte,
   * since it's not relevant.
   */
  #public
  size() -> i32 {
    return _this._byte_length - 1
  }

  /**
   * Checks if the current string is exactly the same as the other string.
   */
  #public
  equals(str other) -> bool {
    bool result

    native {
      if (!other) {
        result = 0;
      } else if (_this->_byte_length != other->_byte_length) {
        result = 0;
      } else {
        result = caffc_strcmp(_this->_caffc_data, other->_caffc_data) == 0 ? 1 : 0;
      }
    }

    return result
  }

  /**
   * Returns the index of another string inside the current string if it exists,
   * or `-1` if it doesn't exists.
   */
  indexOf(str needle) -> i32 {
    if not needle {
      raise("illegal null argument")
    }

    i32 result

    native {
      result = caffc_index_of(_this->_caffc_data, _this->_byte_length - 1,
                              needle->_caffc_data, needle->_byte_length - 1);
    }

    return result
  }
}

native {
  /**
   * strcmp() with CaffC semantics, without a dependency on libC.
   */
  i32 caffc_strcmp(u8* left_string, u8* right_string) {
    while (*left_string && *right_string && *left_string == *right_string) {
      left_string++;
      right_string++;
    }

    return *left_string - *right_string;
  }

  /**
   * indexOf() with CaffC semantics, without a dependency on libC
   */
  i32 caffc_index_of(u8* haystack, i32 haystack_len,
                     u8* needle, i32 needle_len) {
    i32 i, j;

    if (needle_len == 0) return 0;
    if (haystack_len < needle_len) return -1;

    for (i = 0; i <= haystack_len - needle_len; ++i) {
      for (j = 0; j < needle_len; ++j) {
          if (haystack[i + j] != needle[j]) break;
      }
      if (j == needle_len) return i;
    }

    return -1;
  }

  /**
   * memcpy() with CaffC semantics, without a dependency on libC
   */
  void caffc_memcpy(ptr dest, ptr src, i32 size) {
    u8* destPtr = (u8*) dest;
    u8* srcPtr = (u8*) src;
    i32 i;

    for (i = 0; i < size; i++) {
      destPtr[i] = srcPtr[i];
    }
  }

  /**
   * strlen() with CaffC semantics, without a dependency on libC
   */
  i32 caffc_strlen(ptr data) {
    i32 result = 0;

    while (*((char*)data)) {
      result += 1;
      data = (ptr) (((char*)data) + 1);
    }

    return result;
  }
}
