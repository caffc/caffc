module caffc

_caffc_str_size(i32 size) -> i32 {
  i32 result

  native {
    result = (i32) (sizeof(u8) * size + sizeof(caffc_str));
  }

  return result
}

/**
 * A basic string. This implementation only holds ASCII strings.
 */
#public #caffc_array("u8")
class str {
  i32 _byte_length   // size in bytes, including nul byte. this only holds ASCII strings

  constructor(i32 size) {
    if size <= 0 {
      raise("invalid string size.")
    }

    _this._byte_length = size
  }

  /**
   * Creates a copy of the bytes until the first nul byte and creates a new `str` instance.
   * The `ptr` reference isn't stored internally, and a copy of the string will be made.
   */
  #public
  static fromPtr(ptr data) -> str {
     u32 stringLen = _strlen(data)
     str result = new str(stringLen + 1)

     native {
       char* dst = result->_caffc_data;
       char* src = data;

       while (*src) {
         *dst = *src;
         dst++;
         src++;
       }

       *dst = 0;
     }

     return result
  }

  /**
   * Concatenates the current `str`, with the other `str`, into a new `str`
   * instance.
   */
  #public
  add(str other) -> str {
    if not other {
      raise("illegal null argument")
    }

    str result = new str(_this._byte_length + other._byte_length - 1)

    native {
      caffc_memcpy(result->_caffc_data, _this->_caffc_data, _this->_byte_length - 1);
      caffc_memcpy(result->_caffc_data + _this->_byte_length - 1,
                   other->_caffc_data, other->_byte_length); // this copies also the nul byte
    }

    return result
  }

  /**
   * Slices the current `str` into a new `str`. `start` and `end` positions are
   * character indexes (they can be negative). `0` for the `end_index` means
   * `_this.size()`
   */
  #public
  slice(i32 start_index, i32 end_index) -> str {
      if start_index < 0 {
        start_index = (i32) _this._byte_length + start_index - 1
      }

      if (u32) start_index >= (u32) _this._byte_length {
        raise("start_index out of bounds")
      }

      if end_index <= 0 {
        end_index = (i32) _this._byte_length + end_index - 1
      }

      if (u32) end_index > (u32) _this._byte_length {
        raise("end_index out of bounds")
      }

      if start_index > end_index {
        raise("start_index > end_index")
      }

      str result = new str(end_index - start_index + 1)

      native {
        caffc_memcpy(result->_caffc_data,
                     _this->_caffc_data + start_index, result->_byte_length - 1);
        result->_caffc_data[result->_byte_length - 1] = 0;
      }

      return result
  }

  /**
   * Returns the character at the given character position.
   */
  #public
  get(i32 index) -> u32 {
    if index < 0 {
      index = (i32) _this._byte_length + index
    }

    if (u32) index >= (u32) _this._byte_length {
      raise("index out of bounds")
    }

    u32 result

    native {
      result = (u32) _this->_caffc_data[index];
    }

    return result
  }

  /**
   * Returns the size of this string in _characters_. It excludes the nul byte,
   * since it's not relevant.
   */
  #public
  size() -> i32 {
    return _this._byte_length - 1
  }

  /**
   * Checks if the current string is exactly the same as the other string.
   */
  #public
  equals(str other) -> bool {
    if not other {
      return 0
    }

    if _this.size() != other.size() {
      return 0
    }

    for i32 i = 0; i < _this.size(); i += 1 {
      if _this.get(i) != other.get(i) {
        return 0
      }
    }

    return 1
  }

  /**
   * Returns the index of another string inside the current string if it exists,
   * or `-1` if it doesn't exists.
   */
  indexOf(str other) -> i32 {
    if not other {
      raise("illegal null argument")
    }

    i32 thisLength = _this.size()
    i32 otherLength = other.size()

    if (otherLength == 0) {
      return 0
    }

    if (thisLength < otherLength) {
      return -1
    }

    for i32 i = 0; i <= thisLength - otherLength; i += 1 {
      bool match = 1

      for i32 j = 0; j < otherLength; j += 1 {
        if _this.get(i + j) != other.get(j) {
          match = 0
          break
        }
      }

      if (match) {
        return i
      }
    }

    return -1
  }
}

native {
  /**
   * memcpy() with CaffC semantics, without a dependency on libC
   */
  void caffc_memcpy(ptr dest, ptr src, i32 size) {
    u8* destPtr = (u8*) dest;
    u8* srcPtr = (u8*) src;
    i32 i;

    for (i = 0; i < size; i++) {
      destPtr[i] = srcPtr[i];
    }
  }
}

/**
 * Computes the length of the given string. The same as the normal
 * C `strlen`, but without the libc dependency.
 */
_strlen(ptr data) -> i32 {
  i32 result = 0

  native {
    while (*((char*)data)) {
      result += 1;
      data = (ptr) (((char*)data) + 1);
    }
  }

  return result
}

